<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://XinLingJ.github.io/</id>
    <title>LLW</title>
    <updated>2019-12-02T06:51:07.476Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://XinLingJ.github.io/"/>
    <link rel="self" href="https://XinLingJ.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://XinLingJ.github.io//images/avatar.png</logo>
    <icon>https://XinLingJ.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, LLW</rights>
    <entry>
        <title type="html"><![CDATA[JQurey 试题]]></title>
        <id>https://XinLingJ.github.io//post/jqurey-shi-ti</id>
        <link href="https://XinLingJ.github.io//post/jqurey-shi-ti">
        </link>
        <updated>2019-12-01T09:51:13.000Z</updated>
        <content type="html"><![CDATA[<pre><code> 1 jquery中选择器可以分为 基本选择器、层级选择器、过滤选择器、表单选择器、内容选择器、子元素选择器、属性选择器等
2 jQuery选择表单&lt;form&gt;&lt;input type=&quot;text&quot; /&gt;&lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;
        中的第一个表单元素
        $('form input[type=text]')
        $(&quot;form input:first-child&quot;)
        $('input').first()
3 jquery中的$(&quot;#box&quot;).outerWidth(false)返回的是盒子的: 宽包括边框和内留白 不包括外留白;如果为true 也包括外留白
4 jquery中使用过哪些插入节点的方法：prepend prependto append appendto after before insertBefore insertAfter
5 jquery访问对象中的size（）方法的返回值和jQuery对象的 _length_ 属性一样。
6 现有一个表格，如果想要匹配所有行数为偶数的，_even()_实现，奇数的用 _odd()_实现。
7 &quot;在jq中，想让一个元素隐藏用_hide_实现，想让一个元素出现用_show_实现。
8 假设页面有&lt;p&gt;I would like to say: &lt;/p&gt;一个元素，当执行 $(&quot;p&quot;).append(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;);时，
  页面代码会动态加载为 _&lt;p&gt;I would like to say:&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;_
9 &quot;在一个表单里，想要使用jquery找到指定元素的第一个元素用_$(&quot;input&quot;).eq(0)/$(&quot;input&quot;).first()_实现，那么第二个元素用_$(&quot;input&quot;).eq(1)_实现。
10 写出jquery的5个事件：_click_、_mousedown_、_mouseuo_、_focus_、_blur_  mouseover mouseout
11 Jquery如何获取元素属性用prop,移除属性使用_removeProp_
</code></pre>
<p>1	使用JQ有什么好处？
不污染顶级变量   完善的ajax   出色的Dom封装   强大的选择器   轻量级   完善的文档   开源</p>
<p>2	常用的JQ选择器有哪些？
基本选择器（#ID，element，.calss,*,selector1,selector2,selectorN）
层次选择器  基本过滤器选择器  内容  可见性  属性  表单  表单过滤  子元素  子元素过滤</p>
<p>3	JQ中的选择器和CSS中的选择器有什么区别？
jq选择器获得的是dom(document object model)对象   css只是给标签加样式</p>
<p>4	JQ中的选择器有什么优势？
简了代码，节约了性能   强大的选择器   轻量级  完善的文档</p>
<p>5	使用JQ选择器的过程中有哪些需要注意的地方？
引号问题  特殊字符</p>
<p>6	JQ对象和DOM对象是怎样转换的？
var domobj=$(&quot;div&quot;)[0];  domobj.innerHTML=&quot;asad&quot;</p>
<p>7	JQ中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>G</mi><mi>E</mi><mi>T</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">提</mi><mi mathvariant="normal">交</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">.GET()提交和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">和</span></span></span></span>.POST()提交有什么区别？
get会缓存起来有安全问题    储存比较小2k    post可以存很长时间</p>
<p>8	在JQ中是如何操作样式的？ addClass()  removeClass()  toggleClass()</p>
<p>9	一般用什么去递交数据，为什么？ submit</p>
<p>10	在JQ中引入CSS有几种方式？
$(&quot;&quot;).css(&quot;width&quot;:&quot;&quot;,&quot;&quot;:&quot;&quot;)   $(&quot;&quot;).css(function(){})</p>
<p>11	在JQ中有哪些插入节点的方法，他们的区别是什么？
append  appendto  prepend  prependto  after  before  insertAfter  insertBefore</p>
<p>12	JQ中如何获取或设置属性？
$(&quot;&quot;).attr(&quot;&quot;,&quot;&quot;) $().attr({&quot;&quot;:&quot;&quot;,&quot;&quot;:,&quot;&quot;,function(){})</p>
<p>13	JQ中有哪些方法可以遍历节点？  each()   $('div').children()    $('div').find('')</p>
<p>14	子元素选择器和后代选择器元素有什么区别？
后代选择器是后代中所有的都包含    子元素是指其中的某个</p>
<p>15	BEFORSEND方法功能是什么？ beforsend  ajax  向服务器发送请求前添加一些处理函数</p>
<p>16	$(DOCUMENT).READY()方法和WINDOW.ONLOAD有什么区别？
网页DOM都加载完后就可以运行 js可执行多次不被覆盖;
网页内所有内容加载完后  第二次执行会被覆盖;</p>
<p>17	JQ是如何处理缓存的？  ajax
1）通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><mi mathvariant="normal">默</mi><mi mathvariant="normal">认</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">禁</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">缓</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">。</mi><mn>2</mn><mi mathvariant="normal">）</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi></mrow><annotation encoding="application/x-tex">.post()方法来获取数据，那么默认就是禁用缓存的。
    2）通过</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord cjk_fallback">默</span><span class="mord cjk_fallback">认</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">禁</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">缓</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">。</span><span class="mord">2</span><span class="mord cjk_fallback">）</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span></span></span></span>.get()方法来获取数据，可以通过设置时间戳来避免缓存。
3）通过$.ajax方法来获取数据，只要设置参数cache:false即可。</p>
<p>18	<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>G</mi><mi>E</mi><mi>T</mi><mi>S</mi><mi>C</mi><mi>R</mi><mi>I</mi><mi>P</mi><mi>T</mi><mo>(</mo><mo>)</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">.GETSCRIPT()方法和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">和</span></span></span></span>.GETJSON()方法有什么区别？
jQuery提供了<code><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi>S</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mo>(</mo><mo>)</mo><mo>&lt;</mo><mi mathvariant="normal">/</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">.</mi><mi>j</mi><mi>s</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi>H</mi><mi>T</mi><mi>M</mi><mi>L</mi><mi mathvariant="normal">片</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">简</mi><mi mathvariant="normal">单</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">便</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">需</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">对</mi><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi>S</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">进</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">，</mi><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi>S</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">动</mi><mi mathvariant="normal">执</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi>A</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">，</mi><mo>&lt;</mo><mi>c</mi><mi>o</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">.getScript()&lt;/code&gt;方法来直接加载.js文件，
与加载一个HTML片段一样简单方便，并且不需要对JavaScript文件进行处理
，JavaScript文件会自动执行。
与其他Ajax方法一样，&lt;code&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">来</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">L</span><span class="mord cjk_fallback">片</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">简</span><span class="mord cjk_fallback">单</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">需</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">对</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">进</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">动</span><span class="mord cjk_fallback">执</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>.getScript()</code>方法也有回调函数，
它会在JavaScript文件成功载入后运行。例如像载入jQuery官方颜色动画插件（jquery.color.js），
成功后给元素绑定颜色变化动画，就可以用到<code>$.getScript()</code>方法的回调函数。
19	<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 3: (&quot;#̲MSG&quot;).TEXT();和'>(&quot;#MSG&quot;).TEXT();和</span>(&quot;#MSG&quot;).TEST(&quot;<B>NEW CONTENT</B>&quot;);有什么区别？</p>
<p>20	RADIO单选组的第二个元素为当前选中值，该如何获取？
var aa = $('#wrap input[name=&quot;payMethod&quot;]:checked').val();
checkbox       checked</p>
<p>21	选择器中ID,CLASS有什么区别？
当只需要选择一个元素时，使用ID选择器，如果需要选择具有相同 CSS class的元素，就要用class 选择器。</p>
<p>22	JQ表单提交前有哪些校验方法？</p>
<p>23	JQ苦衷的$() 是什么意思？<br>
$就是jquery对象    $()=jquery() 可以传参</p>
<p>24	网页上有五个<DIV>元素，如何使用JQ来选择他们？
$(&quot;div&quot;)[0,1,2,3,4]</p>
<p>25	JQ中的ID选择器和CLASS选择器有何不同？
当只需要选择一个元素时，使用ID选择器，如果需要选择具有相同 CSS class的元素，就要用class 选择器。</p>
<p>26	如何在点击一个按钮时使用JQ隐藏一个图片？
$(&quot;button&quot;).hidden()</p>
<p>27	$(DOCUMENT).READY()是什么函数？为什么更要用它？
网页加载完后运行  ,有些特效需要等网页加载后进行</p>
<p>28	JAVASCRIPT WINDOW.ONLOAD时间和JQ READY函数有什么不同？
jq中的ready 网页DOM都加载完后就可以运行 可执行多次不被覆盖;
window.onload网页内所有内容加载完后  第二次执行会被覆盖;</p>
<p>29	如何找到所有HTML SELECT 标签中的选项？
$('.class option:selected')</p>
<p>30	JQ里的EACH()是什么函数？你是如何使用它的？
遍历   $(&quot;li&quot;).each(function(){alert(aa)});</p>
<p>31	你是如何将一个HTML元素添加到DOM树中的？
append() appendTo() prepend() prependto() append() appendto() after() before()
insertBefore() insertAfter()</p>
<p>32	如何用JQ代码选择所有在段落内部的超链接？$(&quot;a&quot;)</p>
<p>33	$(THIS)和THIS关键字在JQ中有何不同？
代表得对象不同
$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。
而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。
你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。</p>
<p>34	如何使用一个可点击的链接来替换页面中任何的URL？
window.location.href</p>
<p>35	如何检查图像是否已经被完全加载进来？</p>
<p>36	如何利用JQ将页面上的所有元素边框设置为2PX宽的虚线？
$ (&quot;*&quot;).css (&quot;border&quot;, &quot;2px dashed&quot;);</p>
<p>37	删除元素主要方法有几种？这两种方法的区别是什么？<br>
删除匹配的元素集合中所有的子节点。
从DOM中删除所有匹配的元素。  这种比较精准</p>
<p>38	内部插入的方法有哪些？并做文字说明
append() appendto() prependto() prepend()</p>
<p>39	外部插入的方法有哪些？并做文字说明
after()  before()  insertBefore()  insertAfter()</p>
<p>40	写出五个JQ事件
blur focus click mousemove mouseup mousedown</p>
<p>41	JQ的动画效果有哪些？分别概述其实现效果
基本 show()显示 hide()隐藏
滑动 slideDown()下滑 slideUp()上滑 slideToggle()滑动
淡入淡出 fadeIn()淡入  fadeOut()淡出  fadeToggle()淡入淡出切换   fadeTo() 但出到几</p>
<p>42	&quot;JQ如何复制一个元素？不同参数代表什么意义？
一个布尔值（true 或者 false）指示事件处理函数是否会被复制。</p>
<pre><code>2:一个布尔值，指示是否对事件处理程序和克隆的元素的所有子元素的数据应该被复制
</code></pre>
<p>44	在JQ中操作元素的类名的方法有那几个？
addClass()  removeClass()  toggleClass()<br>
hasClass()方法检查被选元素是否包含指定的类名称。如果被选元素包含指定的类，该方法返回 &quot;true&quot;。</p>
<p>45	JQ中怎么获取属性和删除属性？
prop()  attr()      |    removeProp() removeAttr()</p>
<p>46	JQ替换节点的方法有哪些？
replaceWith()  replaceAll()</p>
<p>47	JQ获取子元素、取得匹配元素后面紧邻的同辈元素、取得匹配元素前面紧邻的同辈元素、取得匹配元素前后的所有同辈元素的方法分别是什么？
children()      next()        prev()      siblings()</p>
<p>48	JQ获取元素的定位值、在当前视口的相对偏移
position()              offset()</p>
<p>49	简述$()有那些用法并举例说明</p>
<p>插件	JQuery.fn.extend({checked:function(){},check2..})	  $().checked()
JQuert.extend({checked:function(){}})	  Jquery.checked()</p>
<p>50	举例说明jquery对象和dom对象是怎样转换的<br>
jquery转化为dom对象 $().get(0)<br>
dom转化为jquery对象 var cr = document.getElementsByTagName(&quot;p&quot;)  var $cr = $(cr);</p>
<p>51	jquery中的动画函数有哪些？举例说明<br>
animate() 自定义动画  fadeIn（）淡入效果  fadeOut 淡出效果 fadeTo 渐进的方从不透明到指定的不透明 show() 显示效果  hide() 隐藏效果   slideDown() slideUp() slideToggle()  滑上滑下切换   fadeToggle（） 淡入淡出效果</p>
<p>52	jquery的优点有哪些？
轻量级 强大的选择器  兼容多中浏览器  dom的封装  链式操作方式  丰富的插件</p>
<p>53	jquery插件有哪些？举例并说明用途<br>
js/jquery-ui-1.8.18.custom.min.js    jquery-ui的库文件
js/jquery-ui-timepicker-addon.js     jquery-ui的时间控件
js/jquery-ui-sliderAccess.js         jquery-ui的slider控件，就是滑块的那个</p>
<p>54	jquery中的查找节点函数有哪些？举例说明用途                                                                               $(selector).parent(selector)：获取父节点
$(selector).parentNode：以node[]的形式存放父节点，如果没有父节点，则返回空数组
$(selector).parents(selector)：获取祖先元素</p>
<p>二、jQuery的兄弟节点查找方法
$(selector).prev() / $(selector).previousSibling()：获取上一个兄弟节点
$(selector).prevAll()：获取之前所用的兄弟节点
$(selector).next() / $(selector).nextSibling()：获取下一个兄弟节点
$(selector).nextAll()：获取之后所有的兄弟节点
$(selector).siblings()：获取所有的兄弟节点
三、jQuery的子节点查找方法
$(selector).children()：获取所有直接子节点
$(selector).childNodes：以node[]的形式存放子节点，如果没有子节点，则返回空数组
$(selector).firstChild：获取第一个子节点
$(selector).lastChild：获取最后一个子节点
$(selector).contents：获取包含的所有内容，包括空文本
$(selector).removeChild(selector)：删除并返回指定的子节点
$(selector).replaceChild(selector)：替换并返回指定的子节点</p>
<p>55	jquery中如何添加、删除、切换类名？jquery的效果有哪些？
addClass() removerClass() toggleClass()
自定义动画：animate()  滑动 slideDown()  slideUp() slideToggle()  淡入淡出 fadeIn fadeOut fadeTo fadeToggle
show  hide</p>
<p>56	jquery如何中添加、删除、复制、插入节点的方法是什么？
append() remove() clone() prepend() after() before() insertAfter()</p>
<p>57	jquery中attr()、val()、text()、html() 的用法分别是什么？
attr() 获取匹配的元素集合中的第一个元素的属性的值 或 设置每一个匹配元素的一个或多个属性。
val() 获得匹配元素的当前值。
input的输入框<br>
text() 取得所有匹配元素的内容。
html()取得第一个匹配元素的html内容</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 语句]]></title>
        <id>https://XinLingJ.github.io//post/sql-yu-ju</id>
        <link href="https://XinLingJ.github.io//post/sql-yu-ju">
        </link>
        <updated>2019-11-26T13:22:20.000Z</updated>
        <content type="html"><![CDATA[<pre><code>                        增                                      删                                                 改                                                 查
</code></pre>
<p>库           create database  库名；   drop  database 库名；       alter database 库名 set charset=utf-8;     show databases;
表	          create table 表名;	           drop  table  表名;               alter  table  表名 ;                                      show tables;
字段       alter table                 alter  table
数据</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 试题]]></title>
        <id>https://XinLingJ.github.io//post/js-shi-ti</id>
        <link href="https://XinLingJ.github.io//post/js-shi-ti">
        </link>
        <updated>2019-11-26T10:23:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>1	JS的组成有：ecmascript 基础语法、DOM、BOM
2	访问指定DOM节点的方法有: getElementById(&quot;&quot;)、getElementsByTagName()
3	键盘事件中包括: onkeydown、onkeyup、onkeypress
4	定义数组的方法有: var a = new Array();a=[];a=[3,2,3];
5	DOM结构的顶层元素是: html
6	每隔2秒执行一次指定函数的方法是: setInterval(function(){ },2000)
7	阻止冒泡的方法有: event.stopProragation event.cancelBubble=true
8	JS的基本数据类型有:String、Number、boolean、Null、Undefined
9	为组件添加类属性的方法是: id.setAttribute('class','val');
10	JS中通过ID获取元素的写法是: document.getElementById()
11	根据变量的作用域，可以将变量分为 局部 和 全局
12	字符串对象中，可以用 replace(oldReg, newStr);  splice(idx, len, newStr1,newStr2); 方法替换字符串	
13	JS实现继承父元素的构造函数用的是( 原型链 子类.prototype=new 父类()；)方法	 
14	如果只声明变量，未对其赋值默认为_undefined_	
15	JS获取对象属性的方法是_._和_[]_	
16	JS是运行在_客户端_端的脚本语言	
17	通过_Math.round(7.25)_把7.25四舍五入为最接近的整数？	
18	JS中可以打开名为&quot;window2&quot;的新窗口的方法是_open(url,&quot;window2&quot;)_	
19	表单表示下拉列表的标签是_select_，默认选中某项的属性是_selected_	 
20	&quot;阅读以下代码，在页面中显示的结果是_bc_
      var s=&quot;abcdef  alert(s.substr(1,2))&quot;	
				
	21	单元格纵向合并所有的属性是:rowspan ，默认选中某项的属性是: checked
22	当i等于5时执行一些语句的条件语句是:if(i==5){}
23	Js循环语句有: while 、do-while 及 for
24	Es6模板字符串的符号是: 反引号 `` ，箭头函数的符号是: =&gt;	
25	Es6中定义变量用:let ，定义常量用:const
26	Javascript中通过ID获取元素的写法是:document.getElementById(&quot;id&quot;)
27	JavaScript是运行在 客户端 端的脚本语言。	
28	&quot;阅读以下代码，在页面中会显示出哪个结果：bc
      var  s=&quot;&quot;abcdefg&quot;&quot;;   
      alert (s.substr(1,2)); &quot;	
31	JS有哪些数据类型:字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)
32	通过  nodeType  属性可以判定一个DOM节点的类型	
33	每隔2秒钟执行一次函数x，那么应该使用的代码是 setInterval(fn,2000)
34	&quot;分析下面的JS代码，输出结果为_7__
    var  mystring=&quot;I am a good student&quot;;
    var a=mystring.indexOf(&quot;&quot;good&quot;&quot;);
    document.write(a);&quot;	7
			
35	_getElementById()_  属于访问指定节点的方法	
	
36	Js中可以使用var today = new Date();这样的方法获得系统当前时间，
     假设系统时间是2007-7-2 星期一，则today.getDay()的返回值是_1_   
			 
37	&quot;执行以下脚本语句在页面输出的内容是_true_
     var a=3; a+=8*2; alert(a&gt;10&amp;&amp;a&lt;=20);&quot;	
			 
38	&quot;function move({x,y} = {x:0,y:0}）{
         console.log(x,y);
     }
      move({x:3})
      move({})
     问以上代码输出的内容是_3  undefined_&quot;	
39	JS动态改变标签中内容可以使用的方法是_innerhtml/innertext	
40	通过_nodeType_属性可以判定一个DOM节点的类型	
42	在城市二级联动是使用的是下拉列表的_onChang_事件？
43	_do-while_循环的循环体至少会被执行一次
44	cookie的优点是_刷新页面不用再次加载资源，保存用户登录状态，定制页面_
	
	
    1	成员变量与静态变量的特点	
    a.两个变量的生命周期不同。
      成员变量随着对象的创建而存在，随着对象的被回收而释放。
      静态变量随着类的加载而存在，随着类的消失而消失。
    b.调用方式不同。成员变量只能被对象调用，静态变量可以被对象和类名调用。
    c.别名不同。成员变量为实例变量，静态变量称为类变量。
    d.数据存储位置不同。
      成员变量存储在堆内存中的对象中，所以也叫对象持有的特有数据。
      静态变量数据存储在方法区（共享数据区）的静态区，也叫对象的共享数据。

2	简述JS的继承原理
    js中有一种东西叫做原型链,js引擎会沿着原型链搜索直到Object,Object.prototype.__proto__指向null,到这原型链就结束了.
    如果在这过程中发现属性和方法,那么对象就将拥有 这些属性和方法.

3	循环的种类有几个？写出基本形式
     for while do-while  for-in

4	写出分支语句的结构形式	
    if   if--else   if--else if    switch---case

5	闭包的概念及应用
    闭包就是能够读取其他函数内部变量的函数.

6	内存泄漏产生的原因是什么？如何避免？	
  内存泄漏:
    a)不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）
    b)函数内没有var的变量会变为全局变量，不会被回收. 解决方法: 局部变量前面加var 
    c)闭包内的变量被内部函数调用，无法被回收.  解决方法：局部变量引用后赋值为空
    d)DOM节点添加属性:node.pro={}  解决办法:window.onunload=function(){  node.pro=null } 
    e)element.attachEvent(&quot;&quot;onclick&quot;&quot;, doClick); 
      解决办法:window.onunload=function(){  element.detachEvent('onclick', doClick) }&quot;

7	正则表达式的作用，写出表示北京市座机电话号码的正则表达式。	
   let phoneReg = /((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)/.test(trimString(contactPhone));

8	数组的添加和删除的方法，写出SLICE与SPLICE函数的参数含义	
    unshift() 方法：从数组的开头添加一个或更多元素，并返回数组的长度    头加  
    push() 方法：向数组末尾添加一个或多个元素，并返回数组长度。         尾加 
    shift() 方法：把数组的第一个元素删除，并返回删除的元素值。          头删
    pop() 方法：把数组最后一个元素删除，并返回最后一个元素的值, 如果数组为空则返回undefined。   尾删 

    slice(start,end) 截取 表示从数组start下标开始截取到end下标为止
    splice(index, howmany) 截取 表示从index下标开始删除 howmany个 


9	写出鼠标事件的相关函数
    onClick onMouseover onMouseout onMouseDown onMouseUp onMousemove onFocus onBlur onChange

10	JS中的三种弹出式消息提醒的命令是什么？并简要说明	
    1、警告框alert()，直接弹出不可编辑的框;
    2、确认框 confirm()，显示一个带有 指定消息和确定及取消按钮 的对话框，根据用户点击确认框上的按钮返回true与false。
    3、信息输入框prompt() ，显示可提示用户进行输入的对话框。
       如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。（字符串类型）

12	分别将下小括号（）、中括号[]、大括号{}、冒号：在JS中的作用
    （）函数自执行 （）for循环  []数组  {}函数  ：三位运算 
      
13	写一个递归函数	(阶乘)
    function abc(n){if (n == 1){return 1; }return n * abc(n-1);} console.log(abc(5));

14	数组中slice和splice都有两个参数是，每个参数代表的意义是什么？	
    slice (start,end)  截取 从开始位置到结束位置
    splice (index,howmany) 截取 开始坐标  截取个数

15	添加、删除、替换、插入节点的方法是哪些？
    appendChild()追加节点
    removeChild()删除节点
    insertBefore()插入节点
    replaceChild()替换节点

16	什么是事件冒泡？什么是事件捕捉？如何阻止事件冒泡？
    事件冒泡：事件由小到大,从内到外的传递 
    事件捕获：事件从大到小,从外到内的传递
    阻止冒泡：event.stopPropagation;  ie阻止冒泡：event.cancelBubble=true

17	JS中的typeof返回哪些数据类型？
    typeof的返回值
    字符串(String); 数字(number); 布尔(boolean); 未定义(undefined); 函数(function); 对象(object);

18	以下代码会在console输出什么内容？为什么？
    (function(){var a = b = 3;})();
     console.log(&quot;a defined?&quot; + (typeof a !== 'undefined'));
     console.log(&quot;b defined?&quot; + (typeof b !== 'undefined'));	
     a defined?true 
     b defined?true

19	&quot;在下面的代码中，数字1-4会以什么顺序输出？为什么会这样输出？
   （funcation(){
       console.log(1);
       setTimeout(function(){console.log(2)},1000);
       setTimeout(function(){console.log(3)},0);
       console.log(4);
    })();&quot;	1432

事件委托是什么？
将自己处理的事件委托给父元素执行的过程

20.JS添加、删除、替换、插入到某个节点的方法有哪些？	
   appendChild() 添加节点
   removeChild() 删除节点
   replaceChild() 替换节点
   insertBefore() 插入节点

21	JavaScript中的三种弹出式消息提醒的命令是什么？并简要说明。
    警告框alert(''); 确认框confirm(''); 输入框prompt('');
    
	
23	函数的形参和实参个数是否必须一致，如果不一样，通过什么调用？写一个递归函数
       可以不一样，从左到右依次识别，缺失的默认为undefined 
       递归var s = 0;
       function abc（a,s）{if(a&gt;0){s+=a;a--;return abc(a,s)}else return s;}

24	数组中slice和splice都有两个参数时，每个参数代表的意义是什么？	
    slice(start,end) 表示从数组start下标开始截取到end下标为止
    splice(index, howmany) 表示从index下标开始删除 howmany个 
    
25	本地存储和cookies之间的区别是什么？	
    HTML5本地存储是一种让网页可以把键值对存储在用户浏览器客户端的方法。
    像Cookie一样，这些数据不会因为你打开新网站，刷新页面，乃至关闭你的浏览器而消失。
    而与Cookie不同的时，这些数据不会每次随着HTTP请求被发送到服务器端(当然如果你需要这么做，你可以自己编程实现 ）. 
    因为这是HTML5规范的一部分，这一接口会被浏览器原生支持，不用依赖任何第三方插件。

26	为了让网页更快的加载，你如何处理你的css文件和jS文件，以及图片文件，页面性能优化你还知道哪些方法	
    css和js单独下载一个文件里，图片引用网上的路径	
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js 笔记]]></title>
        <id>https://XinLingJ.github.io//post/js-bi-ji</id>
        <link href="https://XinLingJ.github.io//post/js-bi-ji">
        </link>
        <updated>2019-11-25T02:12:12.000Z</updated>
        <content type="html"><![CDATA[<p><strong>js组成三大核心内容</strong>
（1）ECMAScript 2.3.BOM（browser object document ）是（欧洲计算机制造商协会）它规定了js的语法标准。
（2）DOM（document object model）是文档对象模型，规定了文档的显示结构，可以轻松地删除、添加和替换节点
（3）BOM是浏览器对象模型，就是浏览器自带的一些功能样式，如搜索框，设置，等学习浏览器窗口交互的对象
1、核心（ECMAScript）：描述了JS的语法和基本对象。
2、文档对象模型 （DOM）：处理网页内容的方法和接口。
3、浏览器对象模型（BOM）：与浏览器交互的方法和接口。</p>
<pre><code>	      首先，网页是由一个一个xml的节点构成，页面加载成一刻树状。所以我们通过js操作元素的节点，对元素的增、删、改、查，对元素的属性、值、事件等操作属于DOM操作（ document object model 文档对象模型）。对浏览器框架窗口对象的操作属于BOM操作（Browser Object Model 浏览器对象模型）。js里面还有语法、类型、语句、关键字、运算符、对象等一些是ECMAScript。
</code></pre>
<p>DOM节点类型
　　DOM规定文档中的每个成分都是一个节点（Node）,HTML文档可以说由节点构成的集合，DOM节点有:
　　1. 元素节点（Element）：上图中<html>、<body>、<p>等都是元素节点，即标签。
　　2. 文本节点（Text）:向用户展示的内容，如<li>...</li>中的JavaScript、DOM、CSS等文本。
　　3. 属性节点（Attr）:元素属性，元素才有属性,如<a>标签的链接属性href=&quot;http://www.baidu.com&quot;。
DOM节点三大属性（XML DOM）
　　1. nodeName：元素节点、属性节点、文本节点分别返回元素的名称、属性的名称和#text的字符串。
　 2. nodeType：元素节点、属性节点、文本节点的nodeType值分别为1、2、3.、
　　3. nodeValue：元素节点、属性节点、文本节点的返回值分别为null、属性值和文本节点内容。</p>
<p>DOM常见操作
1. 获取/设置 节点--包括获取/设置 元素节点、属性节点、文本节点 ：
　　获取元素节点：document.getElementById(&quot;ID&quot;)；
　　获取属性节点：getAttributeNode(attrName)；
　　获取文本节点：parentNode/childNodes；
　　设置元素节点： innerHTML属性（innerText属性返回去掉标签的innerHTML）；
　　设置属性节点： setAttribute(attrName,value);
　　设置文本节点：通过改变文本节点的nodeValue来设置文本节点的值；
2. 删除节点
　　删除元素节点： removeChild();
　　删除属性节点：removeAttribute();
　　删除文本节点：textNode.nodeValue='';
3. 创建和添加节点
　  创建节点：通过document对象的createElement(eleName)、createTextNode(nodeValue)方法可分别创建元素节点和文本节点。属性节点也有自己的create方法，但是用的少，直接用元素节点的setAttribute()方法即可添加属性。
　  添加节点：appendChild()和insertBefore()</p>
<p>BOM对象操作windows对象：
Window -对象是 JavaScript层级中的顶层对象，代表一个浏览器窗口或一个框架，会在 <body>或<frameset>每次出现时被自动创建。在这里就只列举一些主干操作。
window.innerHeight - 浏览器窗口的内部高度
window.innerWidth - 浏览器窗口的内部宽度
window.open() - 打开新窗口
window.close() - 关闭当前窗口
window.moveTo() - 移动当前窗口
window.resizeTo() - 调整当前窗口的尺寸....
window.event -事件的状态，例如触发event对象的元素、鼠标的位置及状态、按下的键等等。event对象只在事件发生的过程中才有效。event的某些属性只对特定的事件有意义
window.document -文档对象，操作文档的基础对象
document.getElementById(&quot;id&quot;);根据id找最多找一个；
document.getElementByNames(&quot;name&quot;);根据name找，找出来的是数组；
document.getElementByTagNames(&quot;name&quot;)；根据表签名找，找出来的是数组；
document.getElementByClassNames(&quot;name&quot;)；根据表classname找，找出来的是数组；</p>
<pre><code>BOM（浏览器对象模型）
1、window对象
说明：BOM的核心对象是window，
他表示浏览器的一个实例。
他既是通过JavaScript访问浏览器窗口的一个接口，
又是ECMScript规定的Global对象。
1.1、全局作用域
    全局变量不能通过delete操作符删除；
    window对象上的定义可删除；
1.2、框架
    如果页面中包含框架，那每个框架都拥有自己的window对象，可通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象；
    例：访问上方框架：window.frames[0] 或者 window.frames[&quot;topFrame&quot;] 最好的是top.frames[0];top对象始终指向最高（外）的框架，也就是浏览器窗口；
1.3、打开/关闭窗口
    Window.open（&quot;第一部分&quot;，&quot;第二部分&quot;，&quot;第三部分&quot;，&quot;第四部分&quot;）
        Window.open的特征参数：
        第一部分：写页面地址。
        第二部分：_blank 打开的方式，在新窗口还是自身的窗口。
        第三部分：控制打开的窗口格式，可以写多个，用空格隔开如下：
              toolbar=no    新打开的窗口无工具条 ；
              menubar=no     无菜单栏 status=no状态栏 ；
              width=100 height=100    宽度高度；
              left=100    打开的窗口距离左边多少距离；
              resizable=no    窗口大小不可调 ；
              scrollbars=yes    出现滚动条；
              location=yes    有地址栏；
    Window.open也有返回值，它的返回值是：新打开的窗口对象。
    window.close();    关闭当前窗口
    w.close()：    关闭保存在变量w中的那个窗口；
    关闭多个子窗口：先将打开的窗口存入数组内，利用循环将其挨个关闭；
    window.opener.close()；  关闭打开当前窗口的源窗口
1.4、间隔与延迟
    间隔执行一段代码（函数）：window.setInterval(&quot;要执行的代码&quot;，间隔的毫秒数)
    清除间隔执行：window.clearInterval(间隔的id); 循环一次之后用来清除隔执行的代码
    延迟一段时间执行某一段代码（函数）：window.setTimeout(&quot;要执行的代码&quot;，延迟的毫秒数)
    清除延迟：window.clearTimeout(延迟的id)；清除setTimeout
1.5、系统对话框
    alert();系统对话框 confirm();yes no 选择框 prompt()；提示框
	2、location对象
说明：location最有用的对象之一；既是window对象的属性又是document对象的属性；
window.location	指向同一个对象
document.location	指向同一个对象
2.1、location的属性
hash	返回url中的hash（#后的字符），如果url中不包含，则返回空字符串
host	返回服务器名称和端口号
hostname	返回不带端口号的服务器名称
href        	返回当前加载页面的完整url。（location对象的toString()也返回这个值）
pathname	返回url中的目录和文件名
port    	
返回url指定的端口号，如果不包含则返回空字符串
protocol	返回页面使用的协议。通常为http:或者https
search	返回url查寻字符串 ，？后面的
2.2、改变浏览器的位置 assign()
3、navigator对象
说明：检测显示网页的浏览器类型；常用的是检测是否安装了特定插件；
//检测插件 IE无效
function hasPlugin(name) {
    name = name.toLowerCase();
    for(var i=0;i &lt; navigator.plugins.length;i++){
        if(navigator.plugins[i].name.toLowerCase().indexOf(name) &gt; -1) {
            return true;
        }
    }
    return false;
}
// 检测flash
alert(hasPlugin(&quot;Falsh&quot;));
//IE中检测
function hasIEPlugin(name) {
    try {
        new ActiveXObject(name);
        return true;
    } catch (ex) {
        return false;
    }
}
// 检测falsh
alert(hasIEPlugin(&quot;Falsh&quot;));
		
window.navigator -浏览器的一些信息，用得比较多的也就是navigator.userAgent获取该浏览器的代理信息，如果在使用过程中客户端出现错误，返回服务器携带这些信息做日志记录，排除浏览器版本问题、兼容性等问题。
Window.external -一般用来添加收藏夹，貌似只能用于火狐和ie。。
Window.iframe -文档包含框架（frame 或iframe标签），浏览器会为HTML文档创建一个window对象，并为每个框架创建一个额外的window对象。
window.frames -返回窗口中所有命名的框架
Window.parent -父窗口（如果窗口是顶级窗口，那么parent==self==top）
Window.top -最顶级父窗口（有的窗口中套了好几层frameset或者iframe）
</code></pre>
<p>4、srceen对象
window.screen -用户屏幕信息说明：用处不大，用于站点分析
window.screen.availWidth - 可用的屏幕宽度
window.screen.availHeight - 可用的屏幕高度</p>
<pre><code>Window.self -当前窗口（等价window）
Window.opener -实际上就是通过window.open打开的窗体的父窗体
与消息框有关的方法：alert(String)、confirm(String)、prompt(String)
两种定时器：setTimeout(code,latency) 和setInterval(code,period)

5、history对象
说明：history对象保存着用户上网的历史记录
window.history -对象在编写时可不使用 window 这个前缀，就是在html页面里使用的时候不需要window这个前缀，用了的话有些浏览器可能会报错。
history.back() - 与在浏览器点击后退按钮相同
history.back()	后退一页等同于history(-1);
history.forward() - 与在浏览器中点击按钮向前相同  前一个网页
history.go() - 可以在用户的历史记录中任意跳转
history.go(-1) - 回退到前一个页面
</code></pre>
<p>DOM和BOM区别：
DOM描述了处理网页内容的方法和接口，BOM描述了与浏览器进行交互的方法和接口
1) DOM是W3C的标准[所有浏览器都遵循的标准];
2) DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）;
3) BOM 各个浏览器厂商根据DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同;
4) BOM 主要处理浏览器窗口和框架，
不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。
这些扩展包括
window(窗口)、location（地址栏内容相关）、history（历史）、screen（屏幕）、navigator（有很多浏览器相关的内容，通常判断浏览器类型都是通过这个对象）
DOM 是为了操作文档出现的 API，document 是其的一个对象；
BOM 是为了操作浏览器出现的 API，window 是其的一个对象。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-react 基础]]></title>
        <id>https://XinLingJ.github.io//post/vue-react-ji-chu</id>
        <link href="https://XinLingJ.github.io//post/vue-react-ji-chu">
        </link>
        <updated>2019-11-23T05:38:41.000Z</updated>
        <content type="html"><![CDATA[<xpm>
                    局部组件实例
                    注册一个简单的局部组件 runoob，并使用它：
                    <div id="app">
                        <runoob></runoob>
                    </div>
                    <script>
                        var Child = {
                            template: '<h1>自定义组件!</h1>'
                        }
                        // 创建根实例
                        new Vue({
                            el: '#app',
                            components: {
                                // <runoob> 将只在父模板可用
                                'runoob': Child
                            }
                        })
                    </script>
                    全局组件实例
                    注册一个简单的全局组件 runoob，并使用它：
                    <div id="app">
                        <runoob></runoob>
                    </div>
                    <script>
                        // 注册
                        Vue.component('runoob', {
                            template: '<h1>自定义组件!</h1>'
                        })
                        // 创建根实例
                        new Vue({
                            el: '#app'
                        })
                    </script>
                </xpm>
	<ul>
            <li><h1 style="text-align: center;">生命周期钩子</h1></li>
            <li>Vue2.0的生命周期钩子一共有10个，同样结合官方文档作出了下表</li>
            <li>beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</li>
            <li>created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li>
            <li>beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
            <li>mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li>
            <li>beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
            <li>updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>
            <li>activated     keep-alive 组件激活时调用。</li>
            <li>deactivated    keep-alive 组件停用时调用。</li>
            <li>beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。</li>
            <li>destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
        </ul>
<pre><code>&lt;xmp&gt;
	元素组件：JSX---javaScript XML
         &lt;script type=&quot;text/babel&quot;&gt;&lt;/script&gt;
        var Els=&lt;div&gt;&lt;/div&gt;
 函数式：
       var els=function(){
		   return (&lt;div&gt;11111&lt;div&gt;)
	   }
	   ReactDOM.render(els(),app)
 ES6语法：
       class Els extends React.Component{
		   //state={}
		   constructor(){
			   super()
			   this.state={
				   a:10
			   }
		   }
		   render(){
			   return (&lt;div&gt;11111&lt;/div&gt;)
		   }
	   }
        一个输出 &quot;Hello World！&quot; 的组件，组件名为 HelloMessage：
        &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/babel&quot;&gt;
            function HelloMessage(props) {
                return &lt;h1&gt;Hello World!&lt;/h1&gt;;
            }
            const element = &lt;HelloMessage /&gt;;
            ReactDOM.render(
                element,
                document.getElementById('example')
            );
        &lt;/script&gt;
        我们可以使用函数定义了一个组件：
        function HelloMessage(props) {
        return &lt;h1&gt;Hello World!&lt;/h1&gt;;
        }
        你也可以使用 ES6 class 来定义一个组件:
        class Welcome extends React.Component {
        render() {
        return &lt;h1&gt;Hello World!&lt;/h1&gt;;
        }
        }
        1、getDefaultProps()
        设置默认的props，也可以用dufaultProps设置组件的默认属性.
        2、getInitialState()
        在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props
        3、componentWillMount()
        组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。
        4、 render()
        react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。
        5、componentDidMount()
        组件渲染之后调用，只调用一次。
        更新
        6、componentWillReceiveProps(nextProps)
        组件初始化时不调用，组件接受新的props时调用。
        7、shouldComponentUpdate(nextProps, nextState)
        react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候
        8、componentWillUpdata(nextProps, nextState)
        组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state
        9、render()
        组件渲染
        10、componentDidUpdate()
        组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。
        卸载
        11、componentWillUnmount()
        组件将要卸载时调用，一些事件监听和定时器需要在此时清除。
    &lt;/xmp&gt;</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据类型问题]]></title>
        <id>https://XinLingJ.github.io//post/shu-ju-lei-xing-wen-ti</id>
        <link href="https://XinLingJ.github.io//post/shu-ju-lei-xing-wen-ti">
        </link>
        <updated>2019-11-23T03:56:23.000Z</updated>
        <content type="html"><![CDATA[<ul style="list-style-type:none">
            <li>
                <h1 style="text-align: center;">关于数据类型的前端面试题总结</h1>
            </li>
            <li><b> JavaScript中的数据类型都有哪些？</b></li>
            <li>----数据类型有两种：原始数据类型（又称基础数据类型、可变数据类型）和复杂数据类型（又称对象、不可变数据类型）。</li>
            <li>----原始数据类型包括：undefined，null，数字，字符串，布尔类型，Symbol（ES6 新加入的类型）</li>
            <li>----复杂数据类型包括：包括对象</li>
            <li>--------------------其中对象包括：内部对象（Array、String等），宿主对象（window）和自定义对象。</li>
            <hr />
            <li><b>如何判断一个变量是否为数组？</b></li>
            <li>如果是ES5环境的话，可以用Array.isArray()方法。</li>
            <li>如果不确定运行环境的话，可以用Object.prototype.toString.call()的方法来确认，如果结果是[object Array]则认为数组。</li>
            <hr />
            <li><b>undefined和null的相同与不同？</b></li>
            <li>----相同点：这两个数据类型都只有一个值,都没有方法,都表示“无”，转化为布尔类型时，都是false</li>
            <li>----不同点：</li>
            <li>------null是一个关键字，而undefined不是。</li>
            <li>------null的实质是一个空的对象，而undefined是window的一个属性。</li>
            <li>------进行数字类型转换时，null返回0，undefined返回NaN</li>
            <hr />
            <li><b>隐式类型转化的时候，JavaScript底层都做了哪些处理？</b></li>
            <li>----对象转成原始数据类型时，先调用对象的valueOf方法，如果返回结果不是原始数据类型的值，再调用toString方法。</li>
            <li>----原始类型转原始类型时，直接调用对应的构造函数进行转换，如Number('123')，String(true),Boolean(0)。</li>
            <hr />
            <li><b>有哪些值转化成布尔型后为false？</b></li>
            <li>----包括下面这个六种：</li>
            <li>0、-0、undefined、null、空字符串、NaN</li>
            <hr />
            <li><b>讲讲ES6中的Symbol？</b></li>
            <li>----Symbol是ES6中新加的一个原始类型，他的每个值都是唯一的，即使是用两个完全一样的变量构造出来的Symbol也不相等。</li>
            <li>----原始类型传入Symbol方法时，会进行转换成字符串 再转成Symbol类型值；如果是对象的话，会先调用改对象的toString方法再转成Symbol类型的值。</li>
            <li>----Symbol是最大的用处是用来消除“魔法字符串”的。</li>
            <hr />
            <li><b>如何把字符串转换为数组？</b></li>
            <li>是如果是ES6，可以用Array.from()方法。</li>
            <li>如果不确定环境的话，可以用Array.prototype.slice.call()的方法，将类似数组转换为。</li>
            <li>
                <xmp>
                    Array.from()的详解：（例子来自MDN）
                    Set类型的转换:
                    let s = new Set(['foo', window]);
                    Array.from(s);
                    // ["foo", window]
                    Map类型的转换:
                    let m = new Map([[1, 2], [2, 4], [4, 8]]);
                    Array.from(m);
                    // [[1, 2], [2, 4], [4, 8]]
                    类数组的值:
                    function f() {
                    return Array.from(arguments);
                    }
                    f(1, 2, 3);
                    // [1, 2, 3]
                    Array.from()的第二个参数mapFn也很有用处，可以对于传入的类数组值进行定制化修改:
                    Array.from([1, 2, 3], x => x + x);
                    // [2, 4, 6]
                    Array.from({length: 5}, (v, i) => i);
                    // [0, 1, 2, 3, 4]
                </xmp>
            </li>
        </ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS题]]></title>
        <id>https://XinLingJ.github.io//post/css-ti</id>
        <link href="https://XinLingJ.github.io//post/css-ti">
        </link>
        <updated>2019-11-22T10:25:32.000Z</updated>
        <content type="html"><![CDATA[<ul style="list-style: square;">
        <center>
            <h1>CSS</h1>
        </center>
        <li>加载外部样式文件用的语法：<xmp><link rel=”stylesheet” href=”url” /></xmp></li>
        <li>设置文字或者图片水平居中到一个盒子中的代码：</li>
        <li>父元素：margin:auto;position:relative;width:100px;height:100px;</li>
        <li>子元素：position:absolute;margin:auto;top:0;right:0;bottom:0;left:0;width:30px;height:30px;</li>
        <li>CSS引入网页中的方法： 行内、内联、外联、@import</li>
        <li>CSS选择器有:元素、属性、关系、伪类、伪对象</li>
        <li>CSS如何能够定义列表的项目符号为实心矩形:list-style:square; 或者 list-style-type:square; 圆circle</li>
        <li>css背景图像定位的参数含义:background-position:center center 前者表示垂直平移（-左正右），后者表示水平平移（上-下正）</li>
        <li>css中可以使用z-index的定位是：position的层级，越大越往前显示，需要与position共同作用</li>
        <li>css的颜色定义方式有：16进制、rgb（）、单词</li>
        <li><xmp>css中实现<b><i><del>标签功能的方式分别是：____ font-weight:900;或者 font-weight:bold; </xmp></li>
        <li><xmp>---font-style:italic; del 定义删除的文本  text-decoration:line-through;</xmp></li>
        <li>css伪类中必须放在link后面的是：visited、hover、active</li>
        <li>取消链接下划线的方法：text-decoration:none;</li>
        <li>IE浏览器width属性的计算公式：ie的width为正常的width+padding+border</li>
        <li>css的尺寸单位有：px em in mm vh</li>
        <li>border中可以设置的属性值有：border-width 、border-style、border-color</li>
        <li>CSS选择器优先级是怎样的？ !important >style > id >class > 标签 *</li>
        <hr />
        <li>什么是盒子模型？ CSS技术所使用的一种思维模型</li>
        <li>标准盒子占地面积 == css width+padding+border</li>
        <li>----ie盒子宽 ==width</li>
        <li>----标准盒子 width（css里面） =content宽</li>
        <hr />
        <li style="color: red;">简述清除浮动的方法及各自的优缺点 "父元素 设置高 儿子固定高</li>
        <li>----父元素 overflow:hidden   任意儿子高度</li>
        <li>----父元素 overflow:auto   任意</li>
        <li>----父元素 float:left   父元素本身不占位</li>
        <li>----父元素 display:table   任意</li>
        <li>----父元素 :after{ clear:both}    任意 必须display:block</li>
        <li>----添加兄弟 clear:both   多添加一个儿子</li>
        <li>----添加br  clear:both   多添加标记</li>
        <hr />
        <li>Css使块级元素垂直水平居中的两种方法？ (写出代码)</li>
        <li>---未知盒子宽高</li>
        <li>1-----box1 positon: realtive && box2 position: absolute</li>
        <li>1-----box2盒子 top、left、bottom、right值都设为0></li>
        <li>1-----box2盒子 添加 margin: auto</li>
        <li>1-----box2盒子有border属性时，不影响水平垂直居中 //脱离文档流</li>
        <li>2-----box1 positon: realtive && box2 position: absolute</li>
        <li>2-----box2: top: 50%；left: 50%</li>
        <li>2-----box2盒子使用 css3属性 transform: translate(-50%, -50%)代替margin实现偏移量，偏移量根据自身盒子宽高用百分比进行宽高偏移</li>
        <li>2-----box2盒子有border属性时，不影响水平垂直居中</li>
        <hr />
        <li>谈谈定位的理解？</li>
        <li>----定位可以分为:相对定位(relative)、绝对定位(absolute)、固定定位(fixed)、没有定位(static)</li>
        <li>----relative-相对定位:相对于自己在网页中原有的位置定位，在网页中占一定位置</li>
        <li>----absolute-绝对定位:相对于距离自己最近的有position属性的父系元素定位，脱离文档流在网页中不占位置</li>
        <li>----fixed-固定定位:相对于视窗定位,脱离文档流在网页中不占位置</li>
        <li>----static-没有定位:正常文档布局，在网页中占位置</li>
        <hr />
        <li>你是如何优化你的css?</li>
        <li>----尽量将样式写在单独的css文件里面，方便复用和浏览器缓存</li>
        <li>----避免使用复杂的选择器，层级越少越好，最好不要超过3层</li>
        <li>----利用CSS继承减少代码量,font-size color 可以设置在父系上不用每个单独设置</li>
        <li>----不使用@import</li>
        <li>----精简页面的样式文件，去掉不用的样式</li>
        <li>----慎重使用高性能属性：浮动、定位</li>
        <hr />
        <li>margin和padding的区别和联系: 外边距和内边距，共同完成元素的位置，外边距不加入背景</li>
    </ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML题]]></title>
        <id>https://XinLingJ.github.io//post/html-ti</id>
        <link href="https://XinLingJ.github.io//post/html-ti">
        </link>
        <updated>2019-11-22T09:05:40.000Z</updated>
        <content type="html"><![CDATA[<ul>
        <center>
            <h1>HTML</h1>
        </center>
        <li>HTML的全称是什么？ Hyper Text Markup Language 超文本标记语言</li>
        <li>
            <xmp>©：&copy;|®：&reg;|<：&lt;|>：&gt;|空格符：&nbsp;</xmp>
        </li>
        <li>水平线标签：hr 单标签 ；加粗标签：b 双标签 ；倾斜标签 i 双标签</li>
        <li>HTML中自定义列表的元素包括：自定义列表--dl dt dd 无序列表--ul li 有序列表--ol li</li>
        <li>页面a.html中使用了(a name="charpter1")第一章</a>设置了锚点,</li>
        <li>--要从b.html中跳转到a.html中设施的锚点出,需要在b.html中的a标签内添加：target="a.html#charpter1</li>
        <li>在html中,用于定义表单控件的元素有：text、password、radio、checkbox、submit、reset、button</li>
        <li>在编辑网页时，按“Ctrl+Shift+空格键”插入的HTML源代码为: &nbsp;</li>
        <li><xmp><input>标签type属性的属性值有:text、password、radio、checkbox、submit、reset、button</xmp></li>
        <li>设置下拉列表框中某项被默认选中的属性是:selected</li>
        <li>空标记: br input meta link img …</li>
        <hr />
        <li>前端页面有那三层构成？分别是什么？作用是什么？ </li>
        <li>----结构层 html（布局 搭建页面的结构） </li>
        <li>----表示层 样式css（美化页面的布局结构 添加样式） </li>
        <li>----行为层 js（实现页面的功能 达到某种效果） </li>
        <hr />
        <li>常见的浏览器有哪些？都是什么内核？ </li>
        <li>----IE浏览器 Trident</li>
        <li>----火狐浏览器 Gecko</li>
        <li>----Safari浏览器 webkit</li>
        <li>----谷歌浏览器 Chromium/Blink</li>
        <li>----Opera浏览器 blink</li>
        <hr />
        <li>响应式设计（responsive design）和自适应涉及（adaptive design)的区别？</li>
        <li>-----比较直观的不同是：自适应：需要开发多套界面；响应式开发一套界面</li>
        <li>-----自适应设计 通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。</li>
        <li>-----自适应
            对页面做的屏幕适配是在一定范围：比如pc端（大于1024）一套适配,平板（768-1024）一套适配，手机端（小于768）一套适配;响应式一套页面全部适配。（可以想象：响应式设计要考虑的内容要比自适应设计复杂的多）
        </li>
        <hr />
        <li>谈谈你对网页文档声明的理解:</li>
        <li><xmp>网页中的第一句话是<!doctype html>它是一个注释.表明浏览器我采用的html的版本。它分为 html5声明html4声明3(严格兼容框架集) xhtml1声明3(严格兼容框架集) 版本之间的区别在于标记的数量上</xmp>
        </li>
        <hr />
        <li>input标签的类型有哪些？image month number password radio reset search submit tel text url</li>
        <li>----button checkbox color date email file hidden</li>
        <hr />
        <li>写出全部的img标签属性:</li>
        <li>---align bottom middle left right alt width height border(已废弃)</li>
        <li>---crossoriginNew use-credentials hspace ismap longdesc src usemap vspace</li>
        <hr />
        <li> HTML文档结构是什么？
            <xmp>
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <title>Document</title>
            </head>
            <body></body>
            </html>
            </xmp>
        </li>
        <hr />
        <li>写出url的语法格式 protocol :// hostname[:port] / path / [;parameters][?query]#fragment 协议 主机名 端口 路径 参数 查询 信息 </li>
        <hr />
    </ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML---CSS笔记]]></title>
        <id>https://XinLingJ.github.io//post/html-css-bi-ji</id>
        <link href="https://XinLingJ.github.io//post/html-css-bi-ji">
        </link>
        <updated>2019-11-22T03:15:59.000Z</updated>
        <content type="html"><![CDATA[<ul style="list-style-type:square">
	  <center><li style="list-style: none;"><h1>HTML---CSS</h1></li></center>
    <li><b>HTML不解析输出：<b></li>
    <li>方法一：不需要被解析的html代码放入：xmp 双标签</li>
    <li>备注：从HTML3.2开始反对使用本元素,HTML5规范中本元素已经完全被移除。</li>
    <li>方法二：不需要被解析的html代码放入: pre 双标签  块级元素,<pre> 但 < 需用"&lt;"，> 需用"&gt;"代替即可输出源码。</pre></li>
    <li>方法三：不需要被解析的html代码放入: code 双标签  行内元素,<code> 但 < 需用"&lt;"，> 需用"&gt;"代替即可输出源码。</code></li>
</ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Css3笔记]]></title>
        <id>https://XinLingJ.github.io//post/bi-ji</id>
        <link href="https://XinLingJ.github.io//post/bi-ji">
        </link>
        <updated>2019-11-20T08:40:11.000Z</updated>
        <content type="html"><![CDATA[<ul style="list-style-type:square">
	      <center><h1>Css3</h1></center>
        <li><b>Css3-边框:</b>border-radius box-shadow border-images</li>
        <li>border-image: source slice width outset repeat|initial|inherit;</li>
        <li>border-image-source 用于指定要用于绘制边框的图像的位置</li>
        <li>border-image-slice 图像边界向内偏移</li>
        <li>border-image-width 图像边界的宽度</li>
        <li>border-image-outset 用于指定在边框外部绘制 border-image-area 的量</li>
        <li>border-image-repeat 用于设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。</li>
        <li><b>Css3-圆角:</b>border-radius box-shadow border-images</li>
        <li><b>Css3-背景:</b>background-image background-size background-origin background-clip</li>
        <li>background-clip: border-box|padding-box|content-box;</li>
        <li>border-box 默认值。背景绘制在边框方框内（剪切成边框方框）。</li>
        <li>padding-box 背景绘制在衬距方框内（剪切成衬距方框）。</li>
        <li>content-box 背景绘制在内容方框内（剪切成内容方框）。</li>
        <li>background-clip 规定背景的绘制区域。</li>
        <li>background-origin 规定背景图片的定位区域。</li>
        <li>background-size 规定背景图片的尺寸。</li>
        <li>background-origin: padding-box|border-box|content-box;
        <li>padding-box 背景图像填充框的相对位置</li>
        <li>border-box 背景图像边界框的相对位置</li>
        <li>content-box 背景图像的相对位置的内容框</li>
        <li><b>Css3-渐变</b></li>
        <li>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</li>
        <li>background-image: linear-gradient(direction, color-stop1, color-stop2, ...);</li>
        <li>径向渐变（Radial Gradients）- 由它们的中心定义</li>
        <li>background-image: radial-gradient(shape size at position, start-color, ..., last-color);</li>
        <li>repeating-radial-gradient() 函数用于重复径向渐变：</li>
        <li><b>Css3-文本:</b>text-shadow box-shadow text-overflow 自动换行:word-wrap 单词拆分换行:word-break</li>
        <li>
            <h3 style="color:red">文本溢出省略： white-space: nowrap; overflow: hidden; text-overflow: ellipsis;</h3>
            <h3>文本自动换行： word-wrap:break-word;</h3>
            <h3>单词拆分换行:word-break normal 使用浏览器默认的换行规则。</h3>
            <h3> break-all 允许在单词内换行。</h3>
            <h3> keep-all 只能在半角空格或连字符处换行。</h3>
        </li>
        <li><b>Css3-字体：</b> @font-face{font-family: myFirstFont;src: url(sansation_light.woff);}</li>
        <li><b>Css3-转换：</b>移动 translate(X,Y) 旋转 rotate(xxdeg) 缩放scale(x,y) 切斜skew(x,y) skewX skewY</li>
        <li> matrix()包含旋转缩放移动倾斜</li>
        <li><b>Css3-过渡</b></li>
        <li>--transition 简写属性，用于在一个属性中设置四个过渡属性。</li>
        <li>--transition-property 规定应用过渡的 CSS 属性的名称。</li>
        <li>--transition-duration 定义过渡效果花费的时间。默认是 0。 </li>
        <li>--transition-timing-function 规定过渡效果的时间曲线。默认是 "ease"。 </li>
        <li>--transition-delay 规定过渡效果何时开始。默认是 0。</li>
        <li><b>Css3-动画:</b> animation @keyframes</li>
        <li><b>Css3-多列:</b></li>
        <li>--column-count 指定元素应该被分割的列数。</li>
        <li>--column-fill 指定如何填充列</li>
        <li>--column-gap 指定列与列之间的间隙</li>
        <li>--column-rule 所有 column-rule-* 属性的简写</li>
        <li>--column-rule-color 指定两列间边框的颜色</li>
        <li>--column-rule-style 指定两列间边框的样式</li>
        <li>--column-rule-width 指定两列间边框的厚度</li>
        <li>--column-span 指定元素要跨越多少列</li>
        <li>--column-width 指定列的宽度</li>
        <li>--columns 设置 column-width 和 column-count 的简写</li>
        <li><b>Css3-用户界面</b></li>
        <li>appearance 允许您使一个元素的外观像一个标准的用户界面元素</li>
        <li>box-sizing 允许你以适应区域而用某种方式定义某些元素</li>
        <li>icon 为创作者提供了将元素设置为图标等价物的能力。 </li>
        <li>nav-down 指定在何处使用箭头向下导航键时进行导航 </li>
        <li>nav-index 指定一个元素的Tab的顺序 </li>
        <li>nav-left 指定在何处使用左侧的箭头导航键进行导航 </li>
        <li>nav-right 指定在何处使用右侧的箭头导航键进行导航 </li>
        <li>nav-up 指定在何处使用箭头向上导航键时进行导航 </li>
        <li>outline-offset 外轮廓修饰并绘制超出边框的边缘 </li>
        <li>resize 指定一个元素是否是由用户调整大小</li>
        <li><b>CSS3-框大小:</b> box-sizing 属性可以设置 width 和 height 属性中包含了 padding(内边距) 和 border(边框)。</li>
        <li>默认情况下，元素的宽度与高度计算方式如下：</li>
        <li>width(宽) + padding(内边距) + border(边框) = 元素实际宽度</li>
        <li>height(高) + padding(内边距) + border(边框) = 元素实际高度</li>
        <li><b>Css3-弹性盒子属性:</b></li>
        <li>display 指定 HTML 元素盒子类型。</li>
        <li>flex-direction 指定了弹性容器中子元素的排列方式</li>
        <li>--row 默认值。灵活的项目将水平显示，正如一个行一样。</li>
        <li>--row-reverse 与 row 相同，但是以相反的顺序。</li>
        <li>--column 灵活的项目将垂直显示，正如一个列一样。</li>
        <li>--column-reverse 与 column 相同，但是以相反的顺序。</li>
        <li>--initial 设置该属性为它的默认值。请参阅 initial。</li>
        <li>--inherit 从父元素继承该属性。请参阅 inherit。</li>
        <li>justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。</li>
        <li>--flex-start 默认值。项目位于容器的开头。</li>
        <li>--flex-end 项目位于容器的结尾。</li>
        <li>--center 项目位于容器的中心。</li>
        <li>--space-between 项目位于各行之间留有空白的容器内。</li>
        <li>--space-around 项目位于各行之前、之间、之后都留有空白的容器内。</li>
        <li>--initial 设置该属性为它的默认值。请参阅 initial。</li>
        <li>--inherit 从父元素继承该属性。请参阅 inherit。</li>
        <li>align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</li>
        <li>flex-wrap 设置弹性盒子的子元素超出父容器时是否换行。</li>
        <li>--flex-wrap: nowrap|wrap 必要的时候拆行|wrap-reverse 反拆|initial|inherit;</li>
        <li>align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐</li>
        <li>flex-flow flex-direction 和 flex-wrap 的简写</li>
        <li>order 设置弹性盒子的子元素排列顺序。</li>
        <li>align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。</li>
        <li>flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。</li>
        <li><b>Css3-媒体查询</b></li>
        <li>--@media screen and (max-width: 699px) and (min-width: 520px) {}</li>
        <li>--@media screen and (min-width: 1001px) {}</li>
        <li>--all 用于所有多媒体类型设备|print 用于打印机|screen 用于电脑屏幕，平板，智能手机等。|speech 用于屏幕阅读器</li>
    </ul>
<pre><code>&lt;hr /&gt;
&lt;li&gt;&lt;b&gt;CSS3 多重背景(multiple backgrounds)&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;多重背景，也就是CSS2里background的属性外加origin、clip和size组成的新background的多次叠加，缩写时为用逗号隔开的每组值；用分解写法时，如果有多个背景图片，而其他属性只有一个（例如background-repeat只有一个），表明所有背景图片应用该属性值。
&lt;/li&gt;
&lt;li&gt;语法缩写如下：&lt;/li&gt;
&lt;li&gt;background ： [background-color] | [background-image] | [background-position][/background-size] |&lt;/li&gt;
&lt;li&gt;[background-repeat] | [background-attachment] | [background-clip] | [background-origin],...&lt;/li&gt;
&lt;li&gt;可以把上面的缩写拆解成以下形式：&lt;/li&gt;
&lt;li&gt;background-image:url1,url2,...,urlN;&lt;/li&gt;
&lt;li&gt;background-repeat : repeat1,repeat2,...,repeatN;&lt;/li&gt;
&lt;li&gt; backround-position : position1,position2,...,positionN;&lt;/li&gt;
&lt;li&gt; background-size : size1,size2,...,sizeN;&lt;/li&gt;
&lt;li&gt; background-attachment : attachment1,attachment2,...,attachmentN;&lt;/li&gt;
&lt;li&gt;background-clip : clip1,clip2,...,clipN;&lt;/li&gt;
&lt;li&gt;background-origin : origin1,origin2,...,originN;&lt;/li&gt;
&lt;li&gt;background-color : color;&lt;/li&gt;
&lt;li&gt;注意：&lt;/li&gt;
&lt;li&gt; 用逗号隔开每组 background 的缩写值；&lt;/li&gt;
&lt;li&gt; 如果有 size 值，需要紧跟 position 并且用 &quot;/&quot; 隔开；&lt;/li&gt;
&lt;li&gt; 如果有多个背景图片，而其他属性只有一个（例如 background-repeat 只有一个），表明所有背景图片应用该属性值。&lt;/li&gt;
&lt;li&gt;background-color 只能设置一个。&lt;/li&gt;</code></pre>
]]></content>
    </entry>
</feed>